CREATE TABLE IF NOT EXISTS ayah_bookmark(
  local_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  remote_id TEXT,
  ayah_id INTEGER NOT NULL,
  sura INTEGER NOT NULL,
  ayah INTEGER NOT NULL,
  created_at INTEGER DEFAULT (strftime('%s', 'now')) NOT NULL,
  modified_at INTEGER DEFAULT (strftime('%s', 'now')) NOT NULL,
  -- Ensure deleted is either 0 or 1
  deleted INTEGER NOT NULL DEFAULT 0,
  CHECK (deleted IN (0, 1)),
  UNIQUE(sura, ayah)
);

getBookmarks:
  SELECT * FROM ayah_bookmark WHERE deleted = 0 ORDER BY created_at DESC;

getBookmarkForAyah:
  SELECT * FROM ayah_bookmark WHERE sura = ? AND ayah = ? LIMIT 1;

addNewBookmark {
  INSERT OR IGNORE INTO ayah_bookmark (remote_id, ayah_id, sura, ayah, deleted)
  VALUES (NULL, :ayah_id, :sura, :ayah, 0);
  UPDATE ayah_bookmark
  SET deleted = 0,
    modified_at = strftime('%s', 'now')
  WHERE sura = :sura AND ayah = :ayah;
}

getUnsyncedBookmarks:
  SELECT * FROM ayah_bookmark WHERE remote_id IS NULL OR deleted = 1 ORDER BY created_at DESC;

persistRemoteBookmark:
  INSERT OR REPLACE INTO ayah_bookmark (remote_id, ayah_id, sura, ayah, created_at, modified_at, deleted)
  VALUES (?, ?, ?, ?, ?, ?, 0);

hardDeleteBookmarkFor {
  DELETE FROM ayah_bookmark WHERE remote_id=:remoteID;
}

clearLocalMutationFor {
  DELETE FROM ayah_bookmark WHERE remote_id IS NULL AND local_id = :id;
  UPDATE ayah_bookmark
  SET deleted = 0,
    modified_at = strftime('%s', 'now')
  WHERE local_id = :id;
}

checkRemoteIDsExistence:
  SELECT remote_id FROM ayah_bookmark WHERE remote_id IN :queried_ids;

-- Removes the record of a local bookmark or marks it as deleted if it's remote.
deleteBookmark {
  DELETE FROM ayah_bookmark WHERE sura=:sura AND ayah=:ayah AND remote_id IS NULL;
  UPDATE ayah_bookmark
  SET deleted = 1,
    modified_at = strftime('%s', 'now')
  WHERE sura=:sura AND ayah=:ayah AND remote_id IS NOT NULL;
}
