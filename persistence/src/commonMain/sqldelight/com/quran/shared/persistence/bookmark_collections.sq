CREATE TABLE IF NOT EXISTS bookmark_collection(
  local_id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  remote_id TEXT,
  bookmark_local_id TEXT NOT NULL,
  bookmark_type TEXT NOT NULL,
  collection_local_id INTEGER NOT NULL,
  created_at INTEGER DEFAULT (CAST(strftime('%s', 'now') AS INTEGER) * 1000) NOT NULL,
  modified_at INTEGER DEFAULT (CAST(strftime('%s', 'now') AS INTEGER) * 1000) NOT NULL,
  deleted INTEGER NOT NULL DEFAULT 0,
  CHECK (deleted IN (0, 1)),
  UNIQUE(bookmark_local_id, collection_local_id),
  CHECK (bookmark_type IN ('PAGE','AYAH')),
  FOREIGN KEY(collection_local_id) REFERENCES collection(local_id)
);

CREATE INDEX IF NOT EXISTS bookmark_collection_remote_id_idx ON bookmark_collection(remote_id);

getCollectionBookmarks:
  SELECT * FROM bookmark_collection WHERE deleted = 0 ORDER BY created_at DESC;

getCollectionBookmarksForCollection:
  SELECT * FROM bookmark_collection
  WHERE collection_local_id = ? AND deleted = 0
  ORDER BY created_at DESC;

getCollectionBookmarksWithDetails:
  SELECT
    bc.local_id,
    bc.remote_id,
    bc.bookmark_local_id,
    bc.bookmark_type,
    bc.collection_local_id,
    bc.created_at,
    bc.modified_at,
    bc.deleted,
    c.remote_id AS collection_remote_id,
    c.name AS collection_name,
    pb.page AS page,
    ab.sura AS sura,
    ab.ayah AS ayah
  FROM bookmark_collection bc
  JOIN collection c ON c.local_id = bc.collection_local_id
  LEFT JOIN page_bookmark pb
    ON pb.local_id = CAST(bc.bookmark_local_id AS INTEGER)
    AND bc.bookmark_type = 'PAGE'
  LEFT JOIN ayah_bookmark ab
    ON ab.local_id = CAST(bc.bookmark_local_id AS INTEGER)
    AND bc.bookmark_type = 'AYAH'
  WHERE bc.deleted = 0
  ORDER BY bc.created_at DESC;

getCollectionBookmarksForCollectionWithDetails:
  SELECT
    bc.local_id,
    bc.remote_id,
    bc.bookmark_local_id,
    bc.bookmark_type,
    bc.collection_local_id,
    bc.created_at,
    bc.modified_at,
    bc.deleted,
    c.remote_id AS collection_remote_id,
    c.name AS collection_name,
    pb.page AS page,
    ab.sura AS sura,
    ab.ayah AS ayah
  FROM bookmark_collection bc
  JOIN collection c ON c.local_id = bc.collection_local_id
  LEFT JOIN page_bookmark pb
    ON pb.local_id = CAST(bc.bookmark_local_id AS INTEGER)
    AND bc.bookmark_type = 'PAGE'
  LEFT JOIN ayah_bookmark ab
    ON ab.local_id = CAST(bc.bookmark_local_id AS INTEGER)
    AND bc.bookmark_type = 'AYAH'
  WHERE bc.collection_local_id = :collection_local_id
    AND bc.deleted = 0
  ORDER BY bc.created_at DESC;

getUnsyncedCollectionBookmarksWithDetails:
  SELECT
    bc.local_id,
    bc.remote_id,
    bc.bookmark_local_id,
    bc.bookmark_type,
    bc.collection_local_id,
    bc.created_at,
    bc.modified_at,
    bc.deleted,
    c.remote_id AS collection_remote_id,
    c.name AS collection_name,
    pb.page AS page,
    ab.sura AS sura,
    ab.ayah AS ayah
  FROM bookmark_collection bc
  JOIN collection c ON c.local_id = bc.collection_local_id
  LEFT JOIN page_bookmark pb
    ON pb.local_id = CAST(bc.bookmark_local_id AS INTEGER)
    AND bc.bookmark_type = 'PAGE'
  LEFT JOIN ayah_bookmark ab
    ON ab.local_id = CAST(bc.bookmark_local_id AS INTEGER)
    AND bc.bookmark_type = 'AYAH'
  WHERE bc.remote_id IS NULL OR bc.deleted = 1
  ORDER BY bc.created_at DESC;

getCollectionBookmarkFor:
  SELECT * FROM bookmark_collection
  WHERE bookmark_local_id = ? AND collection_local_id = ? LIMIT 1;

addBookmarkToCollection {
  INSERT OR IGNORE INTO bookmark_collection (
    remote_id,
    bookmark_local_id,
    bookmark_type,
    collection_local_id,
    deleted
  )
  VALUES (NULL, :bookmark_local_id, :bookmark_type, :collection_local_id, 0);
  UPDATE bookmark_collection
  SET deleted = 0,
    modified_at = CAST(strftime('%s', 'now') AS INTEGER) * 1000
  WHERE bookmark_local_id = :bookmark_local_id AND collection_local_id = :collection_local_id;
}

deleteBookmarkFromCollection {
  DELETE FROM bookmark_collection
  WHERE bookmark_local_id = :bookmark_local_id
    AND collection_local_id = :collection_local_id
    AND remote_id IS NULL;
  UPDATE bookmark_collection
  SET deleted = 1,
    modified_at = CAST(strftime('%s', 'now') AS INTEGER) * 1000
  WHERE bookmark_local_id = :bookmark_local_id
    AND collection_local_id = :collection_local_id
    AND remote_id IS NOT NULL;
}

getUnsyncedCollectionBookmarks:
  SELECT * FROM bookmark_collection
  WHERE remote_id IS NULL OR deleted = 1
  ORDER BY created_at DESC;

persistRemoteBookmarkCollection {
  INSERT OR IGNORE INTO bookmark_collection (
    remote_id,
    bookmark_local_id,
    bookmark_type,
    collection_local_id,
    created_at,
    modified_at,
    deleted
  )
  VALUES (
    :remote_id,
    :bookmark_local_id,
    :bookmark_type,
    :collection_local_id,
    :created_at,
    :modified_at,
    0
  );
  UPDATE bookmark_collection
  SET remote_id = :remote_id,
    bookmark_type = :bookmark_type,
    deleted = 0,
    modified_at = :modified_at
  WHERE bookmark_local_id = :bookmark_local_id AND collection_local_id = :collection_local_id;
}

deleteRemoteBookmarkCollectionByRemoteId:
  DELETE FROM bookmark_collection WHERE remote_id = :remote_id;

deleteRemoteBookmarkCollection {
  DELETE FROM bookmark_collection
  WHERE bookmark_local_id = :bookmark_local_id AND collection_local_id = :collection_local_id;
}

clearLocalMutationFor {
  DELETE FROM bookmark_collection WHERE remote_id IS NULL AND local_id = :id;
  UPDATE bookmark_collection
  SET deleted = 0,
    modified_at = CAST(strftime('%s', 'now') AS INTEGER) * 1000
  WHERE local_id = :id;
}

checkRemoteIDsExistence:
  SELECT remote_id FROM bookmark_collection WHERE remote_id IN :queried_ids;
